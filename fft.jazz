#ifndef FFT
#define FFT

#include "montgomery.jazz"
#include "params.jazz"

//really?
//TODO Maybe just cast to reg u64 and back or something instead...
inline
fn do_shift_right(stack u8 value, stack u8 shifts) -> stack u8{
	stack u8 result;
	reg u8 i;
	result = value;
	i = 0;
	while(i < shifts) {
		result >>= 1;
		i += 1;
	}
	return result;
}

// consider precomputing
inline
fn bitreverse(stack u8 x, stack u8 numbits) -> stack u8
{
	stack u8 result;
	stack u8 i;
	stack u8 bit;

	result = 0;	
	
	i = 0;
	while(i < numbits) {
		bit = x;
		bit = do_shift_right(bit, i);
		bit &= 1;
		bit <<= 7;
		bit = do_shift_right(bit, i);
		result |= bit;
		i += 1;
	}

	return result;
}

inline
fn compute_twiddle_factors(inline int butterfly_level, stack u8 butterfly_group)
	-> stack u32[2]
{
	stack u32[2] result;

	stack u8 numbits;
	stack u8 x;
	stack u8 exp;
	//TODO Check if casting to 64 bits is necessary
	reg u64 exp64;

	reg ptr u32[256] ptr_roots_of_unity;
	ptr_roots_of_unity = roots_of_unity;
	
	numbits = butterfly_level;
	numbits += 1;

	x = butterfly_group;
	x <<= 1;

	exp = bitreverse(x, numbits);
	exp64 = (64u) exp;
	// exp64 *= 2 ^ (7 - level)
	// Scales to take into account that we're indexing into 256th roots
	exp64 <<= 7;
	exp64 >>= butterfly_level;

	result[0] = ptr_roots_of_unity[(int) exp64];

	x += 1;

	exp = bitreverse(x, numbits);
	exp64 = (64u) exp;
	exp64 <<= 7;
	exp64 >>= butterfly_level;

	result[1] = ptr_roots_of_unity[(int) exp64];

	return result;
}

inline
fn fft(stack u32[DILITHIUM_polydeg] f) -> stack u32[DILITHIUM_polydeg]
{
	inline int butterfly_level;
	stack u8 num_butterfly_groups;
	stack u8 butterfly_group;
	//Number of butterflies. NOT number of elements.
	stack u64 num_butterflies_per_group;
	//Need u64 for arithmetics?
	reg u64 butterfly_group_start;
	reg u64 butterfly_index;

	//inputs of butterfly
	reg u64 butterfly_left_val;
	reg u64 butterfly_right_val;

	// results of butterfly
	stack u32 temp1;
	stack u32 temp2;

	stack u32[2] twiddle_factors;

	reg u64 butterfly_left_addr;
	reg u64 butterfly_right_addr;


	//Complaint: Can't unroll inner loop...
	//Even though all bounds can be determined at compile time.
	for butterfly_level = 0 to 8 {
		num_butterfly_groups = 1;
		num_butterfly_groups <<= butterfly_level;

		num_butterflies_per_group = 128;
		num_butterflies_per_group >>= butterfly_level;

		butterfly_group = 0;
		while(butterfly_group < num_butterfly_groups) {
			twiddle_factors = compute_twiddle_factors(
				butterfly_level, butterfly_group);

			//group start was u8 but then this doesn't go?
			butterfly_group_start = (64u) butterfly_group;
			butterfly_group_start *= num_butterflies_per_group;
			butterfly_group_start <<= 1;

			butterfly_index = 0;
			while(butterfly_index < num_butterflies_per_group) {
				butterfly_left_addr = butterfly_group_start;
				butterfly_left_addr += butterfly_index;

				butterfly_right_addr = butterfly_left_addr;
				butterfly_right_addr += num_butterflies_per_group;

				butterfly_left_val = (64u) f[(int) butterfly_left_addr];
				butterfly_right_val = (64u) f[(int) butterfly_right_addr];

				temp1 = montgomery_mult(butterfly_right_val, twiddle_factors[0]);
				temp1 = montgomery_add(temp1, butterfly_left_val);

				temp2 = montgomery_mult(butterfly_right_val, twiddle_factors[1]);
				temp2 = montgomery_add(temp2, butterfly_left_val);

				f[(int) butterfly_left_addr] = temp1;
				f[(int) butterfly_right_addr] = temp2;

				butterfly_index += 1;
			}
			butterfly_group += 1;
		}
	}
	return f;
}


// Might not be a good idea to copy and paste code like this
// Only to make very small changes

/*
//TODO inv
fn compute_inv_twiddle_factor(reg u8 butterfly_level, reg u8 butterfly_group)
	-> reg u64
{
	reg u64 result;

	reg u8 numbits;
	reg u8 x;
	reg u8 exp;
	//u64 req. for addressing?
	reg u64 exp64;

	reg ptr u64[256] ptr_roots_of_unity;
	ptr_roots_of_unity = roots_of_unity;
	
	numbits = butterfly_level;
	numbits += 1;

	x = butterfly_group;
	// x <<= 1; x <<= 1;
	// first was there to begin with
	// second is for 2 in the denominator
	x <<= 2;

	// -- inverse -- //

	//x = 256 - x; not doable since x is u8
	x ^= 255;
	x += 1;

	// -- done inverse -- //

	exp = bitreverse(x, numbits);
	exp64 = (64u) exp;

	exp64 <<= 7;
	exp64 >>= butterfly_level;

	result = ptr_roots_of_unity[(int) exp64];
	return result;
}

fn ifft(reg ptr u32[256] f) -> reg ptr u32[256]
{
	reg u8 butterfly_level;
	stack u8 num_butterfly_groups;
	reg u8 butterfly_group;
	//Number of butterflies. NOT number of elements.
	stack u64 num_butterflies_per_group;
	//Need u64 for arithmetics?
	reg u64 butterfly_group_start;
	reg u64 butterfly_index;

	reg u64 inv_twiddle_factor;

	//inputs of butterfly
	reg u64 butterfly_left_val;
	reg u64 butterfly_right_val;

	// results of butterfly
	reg u64 temp1;
	reg u64 temp2;
	reg u64 temp3;

	reg u64 first_twiddle_factor;
	reg u64 second_twiddle_factor;

	reg u64 butterfly_left_addr;
	reg u64 butterfly_right_addr;


	//Complaint: Can't unroll...
	//Even though all bounds can be determined at compile time.
	butterfly_level = 7;
	while(butterfly_level >= 0) {
		num_butterfly_groups = 1;
		
		//variable shift...?
		//why no errors here?
		num_butterfly_groups <<= butterfly_level;

		num_butterflies_per_group = 128;
		num_butterflies_per_group >>= butterfly_level;

		butterfly_group = 0;
		while(butterfly_group < num_butterfly_groups) {

			inv_twiddle_factor = compute_inv_twiddle_factor(butterfly_level, butterfly_group);

			//group start was u8 but then this doesn't go?
			butterfly_group_start = (64u) butterfly_group;
			butterfly_group_start *= num_butterflies_per_group;
			butterfly_group_start <<= 1;

			butterfly_index = 0;
			while(butterfly_index < num_butterflies_per_group) {
				butterfly_left_addr = butterfly_group_start;
				butterfly_left_addr += butterfly_index;

				butterfly_right_addr = butterfly_left_addr;
				butterfly_right_addr += num_butterflies_per_group;

				butterfly_left_val = (64u) f[(int) butterfly_left_addr];
				butterfly_right_val = (64u) f[(int) butterfly_right_addr];

				temp1 = butterfly_right_val;
				temp1 += butterfly_left_val;
				temp1 <<= 1;

				temp1 = butterfly_left_val;
				temp2 += dilithium_modulo;
				temp2 -= butterfly_right_val;
				//this is certainly not constant time...
				if(temp2 > dilithium_modulo) {
					temp2 -= dilithium_modulo;
				}

				/* mont. mult */
				temp2 *= inv_twiddle_factor;
				//always get register merge issues...
				temp3 = montgomery_REDC(temp2);
				
				f[(int) butterfly_left_addr] = (32u) temp1;
				f[(int) butterfly_right_addr] = (32u) temp3;

				butterfly_index += 1;
			}
			butterfly_group += 1;
		}
		butterfly_level += 1;
	}
	return f;
}
*/


#endif
