require "../src/fft.jazz"
require "../src/montgomery.jazz"
require "../src/poly.jazz"

export
fn montgomery_REDC_jazz(reg u64 x) -> reg u32
{
	stack u32 redc_x;
	reg u32 result;
	redc_x = montgomery_REDC(x);
	result = redc_x;
	return result;
}

export
fn fft_jazz(reg u64 vec)
{	
	stack u32[Li2_polydeg] f;
	reg u32 term;

	inline int i;

	for i = 0 to Li2_polydeg {
		term = (u32) [vec + 4 * i];
		f[i] = term;
	}

	f = fft(f);
	
	for i = 0 to Li2_polydeg {
		term = f[i];
		(u32) [vec + 4 * i] = term;
	}
}

/*
export
fn ifft_jazz(reg u64 vec)
{
	stack u32[Li2_polydeg] f;
	reg u32 term;

	inline int i;

	for i = 0 to Li2_polydeg {
		term = (u32) [vec + 4 * i];
		f[i] = term;
	}

	f = ifft(f);
	
	for i = 0 to Li2_polydeg {
		term = f[i];
		(u32) [vec + 4 * i] = term;
	}
}

export
fn fft_poly_mult_jazz(reg u64 ptr_fft_f ptr_fft_g ptr_fft_fg)
{
	stack u32[Li2_polydeg] fft_f fft_g fft_fg;
	inline int i;
	reg u32 v;

	for i = 0 to Li2_polydeg {
		v = (u32) [ptr_fft_f + 4 * i];
		fft_f[i] = v;
		v = (u32) [ptr_fft_g + 4 * i];
		fft_g[i] = v;
	}

	fft_fg = poly_mult(fft_f, fft_g, fft_fg);

	for i = 0 to Li2_polydeg {
		v = fft_fg[i];
		(u32) [ptr_fft_fg + 4 * i] = v;
	}
}
*/

export
fn ifft_to_mont_jazz(reg u64 vec)
{
	stack u32[Li2_polydeg] f;
	reg u32 term;

	inline int i;

	for i = 0 to Li2_polydeg {
		term = (u32) [vec + 4 * i];
		f[i] = term;
	}

	f = ifft_to_mont(f);
	
	for i = 0 to Li2_polydeg {
		term = f[i];
		(u32) [vec + 4 * i] = term;
	}
}
