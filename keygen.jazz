require "fips202.jazz"
require "gen_matrix.jazz"
require "gen_noises.jazz"
require "polyvec.jazz"
require "packing.jazz"

param int PK_LEN = 1952;
param int SK_LEN = 4016;

//reminder to self
//param int SHAKE256_RATE = 136;

inline
fn keygen(stack u8[PK_LEN] pk,
		stack u8[SK_LEN] sk,
		stack u8[32] random_zeta)
		-> stack u8[PK_LEN], stack u8[SK_LEN]
{
	stack u64[25] state;
	stack u8[SHAKE256_RATE] s256_out;

	stack u8[32] rho;
	stack u8[64] rho_prime;
	stack u8[32] k;

	stack u32[Li2_k * Li2_l * Li2_polydeg] fft_matA;
	stack u32[Li2_l * Li2_polydeg] s1;
	stack u32[Li2_k * Li2_polydeg] s2;

	stack u32[Li2_l * Li2_polydeg] fft_s1;

	stack u32[Li2_k * Li2_polydeg] t t1 t0;

	stack u8[10 *  Li2_polydeg * Li2_k / 8] t1_packed;

	reg ptr u8[3 * Li2_polydeg * Li2_k * Li2_l] matrix_dest;

	//temp variables
	reg u8 c;
	reg u64 i;

	// code here
	state = shake256_absorb32(random_zeta);
	state, s256_out = shake256_squeezeblock(state, s256_out);

	//TODO Maybe can load 8 bytes at a time using u64?

	i = 0;
	while(i < 32) {
		c = s256_out[(int) i];
		rho[(int) i] = c;
		i += 1;
	}
	while(i < 96) {
		c = s256_out[(int) i];
		rho_prime[(int) (i - 32)] = c;
		i += 1;
	}
	while(i < 128) {
		c = s256_out[(int) i];
		k[(int) (i - 96)] = c;
		i += 1;
	}

	fft_matA = gen_matrix(rho);
	s1, s2 = gen_noises(rho_prime);
	fft_s1 = fft_vec(s1);

	t = mult_mat_vec(fft_matA, fft_s1);

	//TODO
	//t = ifft(t);
	//TODO
	//t = sum_vecs(t, s2);

	t1, t0 = power2round_vec(t);

	pk[0:32] = rho_pack(rho, pk[0:32]);

	pk[32:10 * Li2_polydeg * Li2_k / 8] = polyt1_pack(
		t1, pk[32:10 * Li2_polydeg * Li2_k / 8]);

	return pk, sk;
}

//zeta is 32 bytes
export
fn keygen_jazz(reg u64 pk_ptr, reg u64 sk_ptr, reg u64 randomness)
{
	stack u8[PK_LEN] pk;
	stack u8[SK_LEN] sk;
	stack u8[32] random_zeta;
	reg u8 c;
	reg u64 i;

	i = 0;
	while(i < 32) {
		c = (u8)[randomness + i];
		random_zeta[(int) i] = c;
		i += 1;
	}

	pk, sk = keygen(pk, sk, random_zeta);

	i = 0;
	while(i < PK_LEN) {
		c = pk[(int) i];
		(u8)[pk_ptr + i] = c;
		i += 1;
	}

	i = 0;
	while(i < SK_LEN) {
		c = sk[(int) i];
		(u8)[sk_ptr + i] = c;
		i += 1;
	}
}
