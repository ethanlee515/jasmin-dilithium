require "fips202.jazz"
require "gen_matrix.jazz"
require "gen_noises.jazz"
require "polyvec.jazz"
require "packing.jazz"

param int PK_LEN = 1952;
param int SK_LEN = 4016;

//reminder to self
//param int SHAKE256_RATE = 136;

inline
fn keygen(stack u8[PK_LEN] pk,
		stack u8[SK_LEN] sk,
		stack u8[32] random_zeta)
		-> stack u8[PK_LEN], stack u8[SK_LEN]
{
	stack u64[25] state;
	stack u8[SHAKE256_RATE] s256_out;

	stack u8[32] rho;
	stack u8[64] rho_prime;
	stack u8[32] k;

	stack u8[3 * Li2_polydeg * Li2_k * Li2_l] mat_A;
	stack u32[Li2_l * Li2_polydeg] s1;
	stack u32[Li2_k * Li2_polydeg] s2;

	stack u32[Li2_k * Li2_polydeg] t t1 t0;

	stack u8[10 *  Li2_polydeg * Li2_k / 8] t1_packed;

	reg ptr u8[3 * Li2_polydeg * Li2_k * Li2_l] matrix_dest;

	//temp variables
	reg u8 c;
	inline int i;

	// code here
	state = shake256_absorb32(random_zeta);
	state, s256_out = shake256_squeezeblock(state, s256_out);

	//TODO optimize
	//Maybe can load 8 bytes at a time using u64
	for i = 0 to 32 {
		c = s256_out[i];
		rho[i] = c;
	}
	for i = 32 to 96 {
		c = s256_out[i];
		rho_prime[i - 32] = c;
	}
	for i = 96 to 128 {
		c = s256_out[i];
		k[i - 96] = c;
	}

	mat_A = gen_matrix(rho);
	s1, s2 = gen_noises(rho_prime);

	//TODO matrix and vector operations
	//s1 = fft_vec(s1);

	t1, t0 = power2round_vec(t);

	pk[0:32] = rho_pack(rho, pk[0:32]);

	pk[32:10 * Li2_polydeg * Li2_k / 8] = polyt1_pack(
		t1, pk[32:10 * Li2_polydeg * Li2_k / 8]);

	return pk, sk;
}

//zeta is 32 bytes
export
fn keygen_jazz(reg u64 pk_ptr, reg u64 sk_ptr, reg u64 randomness)
{
	stack u8[PK_LEN] pk;
	stack u8[SK_LEN] sk;
	stack u8[32] random_zeta;
	reg u8 c;
	inline int i;

	for i = 0 to 32 {
		c = (u8)[randomness + i];
		random_zeta[(int) i] = c;
	}

	pk, sk = keygen(pk, sk, random_zeta);

	for i = 0 to PK_LEN {
		c = pk[i];
		(u8)[pk_ptr + i] = c;
	}

	for i = 0 to SK_LEN {
		c = sk[i];
		(u8)[sk_ptr + i] = c;
	}
}
