require "fips202.jazz"
require "params.jazz"

//reminder to self
//param int SHAKE256_RATE = 136;

inline
fn gen_matrix_entry(stack u8[32] rho, inline int i, inline int j) -> stack u8[3 * 256]
{
	stack u8[3 * 256] result;
	stack u8 term;
	stack u8[3] vs;
	reg u32 value v;
	reg u16 offset;
	stack u64[25] state;
	inline int i;
	reg u8 c;
	reg u64 addr;

	stack u8[34] seed;
	for i = 0 to 32 {
		c = rho[i];
		seed[i] = c;
	}
	//TODO is this the correct order?
	seed[32] = i;
	seed[33] = j;

	state = shake256_absorb34(seed);
	state = __keccakf1600_ref(state);

	offset = 0;
	term = 0;
	while(term < 256) {
		for i = 0 to 3 {
			if(offset >= SHAKE256_RATE) {
				state = __keccakf1600_ref(state);
				offset = 0;
			}
			addr = (64u) offset;
			c = state[u8 (int) addr];
			vs[i] = c;
			offset += 1;
		}

		//umm endianness?
		//TODO little endian for now; will fix later if wrong

		//remove highest bit
		c = vs[2];
		c &= 127;
		vs[2] = c;

		//assemble value
		value = (32u) vs[2];
		for i = 1 to 3 {
			value <<= 8;
			v = (32u) vs[2 - i];
			value += v;
		}

		// End little endian assumption block

		if(value < Li2_q) {
			for i = 0 to 3 {
				//result[3 * term + i] = vs[i]
				addr = (64u) term;
				addr *= 3;
				addr += i;
				result[(int) addr] = vs[i];
			}
			term += 1;
		}
	}

	return result;
}


inline
fn gen_matrix(stack u8[32] rho) -> stack u8[3 * 256 * Li2_k * Li2_l]
{
	stack u8[3 * 256] entry;
	stack u8[3 * 256 * Li2_k * Li2_l] matrix;

	inline int i j k;

	for i = 0 to Li2_k {
		for j = 0 to Li2_l {
			entry = gen_matrix_entry(rho, i, j);
			for k = 0 to 3 * 256 {
				matrix[3 * 256 * (i * Li2_l + j)] = entry[k];
			}
		}
	}

	return matrix;
}
