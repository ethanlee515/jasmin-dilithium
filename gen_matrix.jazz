#ifndef GEN_MATRIX_HH
#define GEN_MATRIX_HH

#include "fips202.jazz"
#include "params.jazz"

//reminder to self
//param int SHAKE256_RATE = 136;

inline
fn gen_entry(stack u8[32] rho, inline int i, inline int j) -> stack u8[3 * 256]
{
	stack u8[3 * 256] result;
	stack u8 term;
	stack u8[3] vs;
	stack u32 value;
	stack u16 offset;
	stack u64[25] state;
	inline int i;
	reg u8 c;
	reg u16 addr;

	stack u8[34] seed;
	for i = 0 to 32 {
		seed[i] = rho[i];
	}
	//TODO is this the correct order?
	seed[32] = i;
	seed[33] = j;

	state = shake256_absorb34(seed);

	offset = 0;
	term = 0;
	while(term < 256) {
		for i = 0 to 3 {
			if(offset >= SHAKE256_RATE) {
				state = __keccakf1600_ref(state);
				offset = 0;
			}
			vs[i] = state[u8 (int) offset];
			offset += 1;
		}

		//umm endianness?
		//TODO little endian for now; will fix later if wrong

		//remove highest bit
		c = vs[2];
		c &= 127;
		vs[2] = c;

		//assemble value
		value = (32u) vs[2];
		for i = 1 to 3 {
			value <<= 8;
			value += (32u) vs[2 - i];
		}

		// End little endian assumption block

		if(value < DILITHIUM_q) {
			for i = 0 to 3 {
				//result[3 * term + i] = vs[i]
				addr = (16u) term;
				addr *= 3;
				addr += i;
				result[(int) addr] = vs[i];
			}
			term += 1;
		}
	}

	return result;
}


inline
fn gen_matrix(stack u8[32] rho) -> stack u8[3 * 256 * DILITHIUM_k * DILITHIUM_l]
{
	stack u8[3 * 256] entry;
	stack u8[3 * 256 * DILITHIUM_k * DILITHIUM_l] matrix;

	inline int i j k;

	for i = 0 to DILITHIUM_k {
		for j = 0 to DILITHIUM_l {
			entry = gen_entry(rho, i, j);
			for k = 0 to 3 * 256 {
				matrix[3 * 256 * (i * DILITHIUM_l + j)] = entry[k];
			}
		}
	}

	return matrix;
}

#endif
