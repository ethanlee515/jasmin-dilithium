require "fips202.jazz"
require "params.jazz"

//reminder to self
//param int SHAKE256_RATE = 136;

inline
fn gen_matrix_entry(stack u8[32] rho, inline int i, inline int j,
	reg ptr u32[Li2_polydeg] result) -> reg ptr u32[Li2_polydeg]
{
	stack u8 term;
	stack u8[3] vs;
	reg u32 value v;
	reg u16 offset;
	stack u64[25] state;
	inline int i;
	reg u8 c;
	reg u64 addr;

	stack u8[34] seed;
	for i = 0 to 32 {
		c = rho[i];
		seed[i] = c;
	}
	//TODO is this the correct order?
	seed[32] = i;
	seed[33] = j;

	state = shake256_absorb34(seed);
	state = __keccakf1600_ref(state);

	offset = 0;
	term = 0;
	while(term < Li2_polydeg) {
		for i = 0 to 3 {
			if(offset >= SHAKE256_RATE) {
				state = __keccakf1600_ref(state);
				offset = 0;
			}
			addr = (64u) offset;
			c = state[u8 (int) addr];
			vs[i] = c;
			offset += 1;
		}

		//remove highest bit
		c = vs[2];
		c &= 127;
		vs[2] = c;

		//assemble value in little endian
		value = (32u) vs[2];
		for i = 1 to 3 {
			value <<= 8;
			v = (32u) vs[2 - i];
			value += v;
		}

		if(value < Li2_q) {
			addr = (64u) term;
			result[(int) addr] = value;
			term += 1;
		}
	}

	return result;
}


inline
fn gen_matrix(stack u8[32] rho) -> stack u32[Li2_k * Li2_l * Li2_polydeg]
{
	reg ptr u32[Li2_polydeg] entry;
	stack u32[Li2_k * Li2_l * Li2_polydeg] matrix;

	inline int i j;

	//TODO double check indexing
	for i = 0 to Li2_k {
		for j = 0 to Li2_l {
			entry = matrix[(i * Li2_l + j) * Li2_polydeg : Li2_polydeg];
			entry = gen_matrix_entry(rho, i, j, entry);
			matrix[(i * Li2_l + j) * Li2_polydeg : Li2_polydeg] = entry;
		}
	}

	return matrix;
}
