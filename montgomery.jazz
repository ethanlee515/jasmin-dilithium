#include "roots_of_unity.jazz"

param int twoTo32 = 4294967296;
param int twoTo32Minus1 = 4294967295;
param int dilithium_modulo = 8380417;
param int dilithium_modulo_left_shift_41 = 18428731874223325184;
param int dilithium_modulo_inv = 58728449;
param int dilithium_modulo_inv_neg = 4236238847;
param int dilithium_primitive_root = 1753;
param int m_1 = 4193792;
param int m_root = 2091667;

// Making this inline resolves conflicting register issues...
// Otherwise "x = montgomery_REDC(x) apparently doesn't work.
inline fn montgomery_REDC(reg u64 x) -> reg u64
{
	reg u64 m;

	//m = ((x & twoTo32Minus1) * dilithium_modulo_inv_neg) & twoTo32Minus1;
	m = x;
	m &= twoTo32Minus1;
	m *= dilithium_modulo_inv_neg;
	m &= twoTo32Minus1;

	//t = (x + m * dilithium_N) >> 32
	m *= dilithium_modulo;
	m += x;
	m = m >> 32;

	if(m >= dilithium_modulo) {
		m -= dilithium_modulo;
	}
	return m;
}

//really?
inline fn do_shift_right(stack u8 value, stack u8 shifts) -> stack u8{
	stack u8 result;
	reg u8 i;
	result = value;
	i = 0;
	while(i < shifts) {
		result >>= 1;
		i += 1;
	}
	return result;
}

fn bitreverse(reg u8 x, reg u8 numbits) -> reg u8
{
	reg u8 result;
	stack u8 i;
	stack u8 bit;

	result = 0;	
	
	i = 0;
	while(i < numbits) {
		bit = x;
		bit = do_shift_right(bit, i);
		bit &= 1;
		bit <<= 7;
		bit = do_shift_right(bit, i);
		result |= bit;
		i += 1;
	}

	return result;
}

fn compute_first_twiddle_factor(reg u8 butterfly_level, reg u8 butterfly_group)
	-> reg u64
{
	reg u64 result;

	reg u8 numbits;
	reg u8 x;
	reg u8 exp;
	//u64 req. for addressing?
	reg u64 exp64;

	reg ptr u64[256] ptr_roots_of_unity;
	ptr_roots_of_unity = roots_of_unity;
	
	numbits = butterfly_level;
	numbits += 1;

	x = butterfly_group;
	x <<= 1;

	exp = bitreverse(x, numbits);
	exp64 = (64u) exp;
	result = ptr_roots_of_unity[(int) exp64];

	return result;
}

//Not very efficient...
//But runs out of register otherwise?
fn compute_second_twiddle_factor(reg u8 butterfly_level, reg u8 butterfly_group)
	-> reg u64
{
	reg u64 result;

	reg u8 numbits;
	reg u8 x;
	reg u8 exp;
	//u64 req. for addressing?
	reg u64 exp64;

	reg ptr u64[256] ptr_roots_of_unity;
	ptr_roots_of_unity = roots_of_unity;
	
	numbits = butterfly_level;
	numbits += 1;

	x = butterfly_group;
	x <<= 1;
	x += 1;
	exp = bitreverse(x, numbits);
	exp64 = (64u) exp;
	result = ptr_roots_of_unity[(int) exp64];

	return result;
}

fn fft(reg ptr u32[256] f) -> reg ptr u32[256]
{
	reg u8 butterfly_level;
	stack u8 num_butterfly_groups;
	reg u8 butterfly_group;
	//Number of butterflies. NOT number of elements.
	stack u64 num_butterflies_per_group;
	//Need u64 for arithmetics?
	reg u64 butterfly_group_start;
	reg u64 butterfly_index;

	//inputs of butterfly
	reg u64 butterfly_left_val;
	reg u64 butterfly_right_val;

	// results of butterfly
	reg u64 temp1;
	reg u64 temp2;

	reg u64 first_twiddle_factor;
	reg u64 second_twiddle_factor;

	reg u64 butterfly_left_addr;
	reg u64 butterfly_right_addr;


	//Complaint: Can't unroll...
	//Even though all bounds can be determined at compile time.
	butterfly_level = 0;
	while(butterfly_level < 8) {
		num_butterfly_groups = 1;
		
		//variable shift...?
		//why no errors here?
		num_butterfly_groups <<= butterfly_level;

		num_butterflies_per_group = 128;
		num_butterflies_per_group >>= butterfly_level;

		butterfly_group = 0;
		while(butterfly_group < num_butterfly_groups) {

			first_twiddle_factor = compute_first_twiddle_factor(butterfly_level, butterfly_group);
			second_twiddle_factor = compute_second_twiddle_factor(butterfly_level, butterfly_group);

			//group start was u8 but then this doesn't go?
			butterfly_group_start = (64u) butterfly_group;
			butterfly_group_start *= num_butterflies_per_group;
			butterfly_group_start <<= 1;

			butterfly_index = 0;
			while(butterfly_index < num_butterflies_per_group) {
				butterfly_left_addr = butterfly_group_start;
				butterfly_left_addr += butterfly_index;

				butterfly_right_addr = butterfly_left_addr;
				butterfly_right_addr += num_butterflies_per_group;

				butterfly_left_val = (64u) f[(int) butterfly_left_addr];
				butterfly_right_val = (64u) f[(int) butterfly_right_addr];

				temp1 = butterfly_right_val;

				/* mont. mult */
				temp1 *= first_twiddle_factor;
				temp1 = montgomery_REDC(temp1);
				
				/* mont. add */
				temp1 += butterfly_left_val;
				if(temp1 >= dilithium_modulo) {
					temp1 -= dilithium_modulo;
				}

				temp2 = butterfly_right_val;

				/* mont. mult */
				temp2 *= second_twiddle_factor;
				temp2 = montgomery_REDC(temp2);

				/* mont. add */
				temp2 += butterfly_left_val;
				if(temp2 >= dilithium_modulo) {
					temp2 -= dilithium_modulo;
				}
				
				f[(int) butterfly_left_addr] = (32u) temp1;
				f[(int) butterfly_right_addr] = (32u) temp2;

				butterfly_index += 1;
			}
			butterfly_group += 1;
		}
		butterfly_level += 1;
	}
	return f;
}

