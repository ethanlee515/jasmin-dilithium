param int twoTo32 = 4294967296;
param int twoTo32Minus1 = 4294967295;
param int dilithium_modulo = 8380417;
param int dilithium_modulo_left_shift_41 = 18428731874223325184;
param int dilithium_modulo_inv = 58728449;
param int dilithium_modulo_inv_neg = 4236238847;
param int dilithium_primitive_root = 1753;
param int m_1 = 4193792;
param int m_root = 2091667;

// Actually u32 is enough to store a number in montgomery form...
inline fn montgomery_REDC(reg u64 x) -> reg u64
{
	reg u64 m;

	//m = ((x & twoTo32Minus1) * dilithium_modulo_inv_neg) & twoTo32Minus1;
	m = x;
	m &= twoTo32Minus1;
	m *= dilithium_modulo_inv_neg;
	m &= twoTo32Minus1;

	//t = (x + m * dilithium_N) >> 32
	m *= dilithium_modulo;
	m += x;
	m = m >> 32;

	if(m >= dilithium_modulo) {
		m -= dilithium_modulo;
	}
	return m;
}

//really?
inline fn do_shift_right(stack u8 value, stack u8 shifts) -> stack u8{
	stack u8 result;
	reg u8 i;
	result = value;
	i = 0;
	while(i < shifts) {
		result >>= 1;
		i += 1;
	}
	return result;
}

fn bitreverse(reg u8 x, reg u8 numbits) -> reg u8
{
	reg u8 result;
	stack u8 i;
	stack u8 bit;

	result = 0;	
	
	i = 0;
	while(i < numbits) {
		bit = x;
		bit = do_shift_right(bit, i);
		bit &= 1;
		bit <<= 7;
		bit = do_shift_right(bit, i);
		result |= bit;
		i += 1;
	}

	return result;
}

export fn fft(reg u64 f, reg u64 precomputed_roots)
{
	reg u8 butterfly_level;
	stack u8 num_butterfly_groups;
	reg u8 butterfly_group;
	//Number of butterflies. NOT number of elements.
	stack u64 num_butterflies_per_group;
	//Need u64 for arithmetics?
	reg u64 butterfly_group_start;
	reg u64 butterfly_index;
	// results of butterfly
	reg u64 temp1;
	reg u64 temp2;

	//for twiddle factor computation
	reg u8 numbits;
	reg u8 x;
	reg u8 exp;
	//u64 req. for addressing?
	reg u64 exp64;

	stack u64 first_twiddle_factor;
	stack u64 second_twiddle_factor;

	reg u64 butterfly_left_addr;
	reg u64 butterfly_right_addr;

	//Complaint: Can't unroll...
	//Even though all bounds can be determined at compile time.
	butterfly_level = 0;
	while(butterfly_level < 8) {
		num_butterfly_groups = 1;
		
		//variable shift...?
		//why no errors here?
		num_butterfly_groups <<= butterfly_level;

		num_butterflies_per_group = 128;
		num_butterflies_per_group >>= butterfly_level;

		butterfly_group = 0;
		while(butterfly_group < num_butterfly_groups) {

			// -- compute twiddle factors -- //

			numbits = butterfly_level;
			numbits += 1;

			x = butterfly_group;
			x <<= 1;

			//compilation error in functions fft and fft at position line 166: assembler error lea: not able to assemble address
			//PLEASE REPORT

			exp = bitreverse(x, numbits);
			exp64 = (64u) exp;
			first_twiddle_factor = [precomputed_roots + 8 * exp64];

			x += 1;
			exp = bitreverse(x, numbits);
			exp64 = (64u) exp;
			second_twiddle_factor = [precomputed_roots + 8 * exp64];

			// -- end compute twiddle factors -- //

			//group start was u8 but then this doesn't go?
			butterfly_group_start = (64u) butterfly_group;
			butterfly_group_start *= num_butterflies_per_group;
			butterfly_group_start <<= 1;

			butterfly_index = 0;
			while(butterfly_index < num_butterflies_per_group) {
				butterfly_left_addr = butterfly_group_start;
				butterfly_left_addr += butterfly_index;

				butterfly_right_addr = butterfly_left_addr;
				butterfly_right_addr += num_butterflies_per_group;

				temp1 = [f + butterfly_right_addr * 8];
				/* mont. mult */
				temp1 *= first_twiddle_factor;
				temp1 = montgomery_REDC(temp1);
				
				/* mont. add */
				temp1 += [f + butterfly_left_addr * 8];
				if(temp1 >= dilithium_modulo) {
					temp1 -= dilithium_modulo;
				}

				temp2 = [f + butterfly_right_addr * 8];
				/* mont. mult */
				temp2 *= second_twiddle_factor;
				temp2 = montgomery_REDC(temp2);
				/* mont. add */
				temp2 += [f + butterfly_left_addr * 8];
				if(temp2 >= dilithium_modulo) {
					temp2 -= dilithium_modulo;
				}

				[f + butterfly_left_addr * 8] = temp1;
				[f + butterfly_right_addr * 8] = temp2;

				butterfly_index += 1;
			}
			butterfly_group += 1;
		}
		butterfly_level += 1;
	}
}

