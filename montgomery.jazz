param int twoTo32 = 4294967296;
param int twoTo32Minus1 = 4294967295;
param int dilithium_modulo = 8380417;
param int dilithium_modulo_left_shift_41 = 18428731874223325184;
param int dilithium_modulo_inv = 58728449;
param int dilithium_modulo_inv_neg = 4236238847;
param int dilithium_primitive_root = 1753;
param int m_1 = 4193792;
param int m_root = 2091667;

/* UNUSED; things are supposed to be precomputed instead.
fn brute_force_mod(reg u64 x) -> reg u64
{
	reg u64 result;
	reg u64 temp;
	result = x;
	temp = dilithium_modulo_left_shift_41;
	while(temp >= dilithium_modulo) {
		if(result >= temp) {
			result -= temp;
		}
		temp >>= 1;
	}
	return result;
}

export fn montgomery(reg u32 x) -> reg u64
{
	reg u64 y;
	y = (64u) x;
	y <<= 32;
	y = brute_force_mod(y);
	return y;
}
*/

// Actually u32 is enough to store a number in montgomery form...
export fn montgomery_REDC(reg u64 x) -> reg u64
{
	reg u64 m;

	//m = ((x & twoTo32Minus1) * dilithium_modulo_inv_neg) & twoTo32Minus1;
	m = x;
	m &= twoTo32Minus1;
	m *= dilithium_modulo_inv_neg;
	m &= twoTo32Minus1;

	//t = (x + m * dilithium_N) >> 32
	m *= dilithium_modulo;
	m += x;
	m = m >> 32;

	if(m >= dilithium_modulo) {
		m -= dilithium_modulo;
	}
	return m;
}

/*
export fn montgomery_mult(reg u64 mx, reg u64 my) -> reg u64
{
	reg u64 prod;

	prod = mx * my;
	prod = montgomery_REDC(prod);

	return prod;
}

fn montgomery_add(reg u64 mx, reg u64 my) -> reg u64
{
	reg u64 sum;
	sum = mx + my;
	if(sum >= dilithium_modulo) {
		sum -= dilithium_modulo;
	}
	return sum;
}
*/

//really?
fn do_shift_right(stack u8 value, stack u8 shifts) -> stack u8{
	stack u8 result;
	reg u8 i;
	result = value;
	i = 0;
	while(i < shifts) {
		result >>= 1;
		i += 1;
	}
	return result;
}

fn bitreverse(reg u8 x, reg u8 numbits) -> reg u8
{
	reg u8 result;
	stack u8 i;
	stack u8 bit;

	result = 0;	
	
	i = 0;
	while(i < numbits) {
		bit = x;
		bit = do_shift_right(bit, i);
		bit &= 1;
		bit <<= 7;
		bit = do_shift_right(bit, i);
		result |= bit;
		i += 1;
	}

	return result;
}

export fn test_read_array(reg u64 ptr) -> reg u64 {
	reg u64 result;
	result = [ptr + 8];
	return result;
}

/*
export fn compute_first_twiddle_factor(reg u8 butterfly_level,
											reg u8 butterfly_group,
											reg u64 roots) -> reg u64 {
	reg u8 numbits;
	reg u8 x;
	reg u8 exp;
	reg u64 result;
	reg u64 exp64;

	numbits = butterfly_level;
	numbits += 1;

	x = butterfly_group;
	x <<= 1;

	//compilation error in functions fft and fft at position line 166: assembler error lea: not able to assemble address
	//PLEASE REPORT

	exp = bitreverse(x, numbits);
	exp64 = (64u) exp;
	result = [roots + 8 * exp64];
	return result;
}

export fn compute_second_twiddle_factor(reg u8 butterfly_level,
											reg u8 butterfly_group,
											reg u64 roots) -> reg u64 {
	reg u8 numbits;
	reg u8 x;
	reg u8 exp;
	reg u64 result;
	reg u64 exp64;

	numbits = butterfly_level;
	numbits += 1;

	x = butterfly_group;
	x <<= 1;
	x += 1;

	//compilation error in functions fft and fft at position line 166: assembler error lea: not able to assemble address
	//PLEASE REPORT

	exp = bitreverse(x, numbits);
	exp64 = (64u) exp;
	result = [roots + 8 * exp64];
	return result;
}
*/

export fn fft(reg u64 f, reg u64 precomputed_roots)
{
	reg u8 butterfly_level;
	reg u8 num_butterfly_groups;
	reg u8 butterfly_group;
	//Number of butterflies. NOT number of elements.
	//u64 for address?
	reg u64 num_butterflies_per_group;
	// apparently has to be u64 to do math?
	reg u64 butterfly_group_start;
	//u64 for indexing?
	reg u64 butterfly_index;
	// results of butterfly
	reg u64 temp1;
	reg u64 temp2;

	//for twiddle factor computation
	reg u8 numbits;
	reg u8 x;
	reg u8 exp;
	//u64 req. for addressing?
	reg u64 exp64;

	stack u64 first_twiddle_factor;
	stack u64 second_twiddle_factor;

	reg u64 butterfly_left_addr;
	reg u64 butterfly_right_addr;

	//Complaint: Can't unroll...
	//Even though all bounds can be determined at compile time.
	butterfly_level = 0;
	while(butterfly_level < 8) {
		num_butterfly_groups = 1;
		
		//variable shift...?
		//why no errors here?
		num_butterfly_groups <<= butterfly_level;

		num_butterflies_per_group = 128;
		num_butterflies_per_group >>= butterfly_level;

		butterfly_group = 0;
		while(butterfly_group < num_butterfly_groups) {

			// -- compute twiddle factors -- //

			numbits = butterfly_level;
			numbits += 1;

			x = butterfly_group;
			x <<= 1;

			//compilation error in functions fft and fft at position line 166: assembler error lea: not able to assemble address
			//PLEASE REPORT

			//TODO bring back
			exp = bitreverse(x, numbits);
			exp64 = (64u) exp;
			first_twiddle_factor = [precomputed_roots + 8 * exp64];

			x += 1;
			//TODO bring back
			exp = bitreverse(x, numbits);
			exp64 = (64u) exp;
			second_twiddle_factor = [precomputed_roots + 8 * exp64];

			// -- end compute twiddle factors -- //

			//group start was u8 but then this doesn't go?
			butterfly_group_start = (64u) butterfly_group;
			butterfly_group_start *= num_butterflies_per_group;
			butterfly_group_start <<= 1;

			butterfly_index = 0;
			while(butterfly_index < num_butterflies_per_group) {
				butterfly_left_addr = butterfly_group_start;
				butterfly_left_addr += butterfly_index;

				butterfly_right_addr = butterfly_left_addr;
				butterfly_right_addr += num_butterflies_per_group;

				temp1 = [f + butterfly_right_addr * 8];
				/* mont. mult */
				temp1 *= first_twiddle_factor;
				temp1 = montgomery_REDC(temp1);
				/* mont. add */
				temp1 += [f + butterfly_left_addr * 8];
				if(temp1 >= dilithium_modulo) {
					temp1 -= dilithium_modulo;
				}

				temp2 = [f + butterfly_right_addr * 8];
				/* mont. mult */
				temp2 *= second_twiddle_factor;
				temp2 = montgomery_REDC(temp2);
				/* mont. add */
				temp2 += [f + butterfly_left_addr * 8];
				if(temp2 >= dilithium_modulo) {
					temp2 -= dilithium_modulo;
				}

				[f + butterfly_left_addr * 8] = temp1;
				[f + butterfly_right_addr * 8] = temp2;

				butterfly_index += 1;
			}
			butterfly_group += 1;
		}
		butterfly_level += 1;
	}
}

