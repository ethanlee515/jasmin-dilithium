require "fips202.jazz"
require "gen_matrix.jazz"
require "gen_noises.jazz"
require "polyvec.jazz"
require "packing.jazz"

param int PK_LEN = 1952;
param int SK_LEN = 4000;

//reminder to self
//param int SHAKE256_RATE = 136;

inline
fn keygen(stack u8[PK_LEN] pk,
		stack u8[SK_LEN] sk,
		stack u8[32] random_zeta)
		-> stack u8[PK_LEN], stack u8[SK_LEN]
{
	stack u64[25] state;
	stack u8[SHAKE256_RATE] s256_out;

	stack u8[32] rho;
	stack u8[64] rho_prime;
	stack u8[32] k;

	stack u32[Li2_k * Li2_l * Li2_polydeg] fft_matA;
	stack u32[Li2_l * Li2_polydeg] s1;
	stack u32[Li2_k * Li2_polydeg] s2;

	stack u32[Li2_l * Li2_polydeg] m_s1;
	stack u32[Li2_k * Li2_polydeg] m_s2;

	stack u32[Li2_l * Li2_polydeg] fft_s1;

	stack u32[Li2_k * Li2_polydeg] t t1 t0;

	stack u8[10 *  Li2_polydeg * Li2_k / 8] t1_packed;

	reg ptr u8[3 * Li2_polydeg * Li2_k * Li2_l] matrix_dest;

	reg ptr u32[Li2_l * Li2_polydeg] s1ptr;

	//temp variables
	reg u8 c;
	reg u64 i;

	// code here
	state = shake256_absorb32(random_zeta);
	state, s256_out = shake256_squeezeblock(state, s256_out);

	//TODO Maybe can load 8 bytes at a time using u64?

	i = 0;
	while(i < 32) {
		c = s256_out[(int) i];
		rho[(int) i] = c;
		i += 1;
	}
	while(i < 96) {
		c = s256_out[(int) i];
		rho_prime[(int) (i - 32)] = c;
		i += 1;
	}
	while(i < 128) {
		c = s256_out[(int) i];
		k[(int) (i - 96)] = c;
		i += 1;
	}

	fft_matA = gen_matrix(rho);

	s1, s2 = gen_noises(rho_prime);

	// montgomery forms
	m_s1 = make_montgomery_of_s1(s1);
	m_s2 = make_montgomery_of_s2(s2);

	fft_s1 = fft_vec(m_s1);

	t = mult_mat_vec(fft_matA, fft_s1);
	t = ifft_vec(t);
	t = sum_vecs(t, m_s2);

	// montgomery reduce
	t = redc_t(t);

	t1, t0 = power2round_vec(t);

	pk[0:32] = rho_pack(rho, pk[0:32]);

	pk[32 : Li2_pack_t1len] = polyt1_pack(
		t1, pk[32 : Li2_pack_t1len]);
	
	sk[0:32] = rho_pack(rho, sk[0:32]);
	sk[32:32] = rho_pack(k, sk[32:32]); 

	//TODO
	//sk[64:32] = rho_pack(tr, sk[64:32]);

	sk[96 : Li2_pack_s1len] = pack_s1(
		s1, sk[96 : Li2_pack_s1len]);

	sk[Li2_pack_s2loc : Li2_pack_s2len] = pack_s2(
		s2, sk[Li2_pack_s2loc : Li2_pack_s2len]);

	return pk, sk;
}

//zeta is 32 bytes
export
fn keygen_jazz(reg u64 pk_ptr, reg u64 sk_ptr, reg u64 randomness)
{
	stack u8[PK_LEN] pk;
	stack u8[SK_LEN] sk;
	stack u8[32] random_zeta;
	reg u8 c;
	reg u64 i;

	i = 0;
	while(i < 32) {
		c = (u8)[randomness + i];
		random_zeta[(int) i] = c;
		i += 1;
	}

	pk, sk = keygen(pk, sk, random_zeta);

	i = 0;
	while(i < PK_LEN) {
		c = pk[(int) i];
		(u8)[pk_ptr + i] = c;
		i += 1;
	}

	i = 0;
	while(i < SK_LEN) {
		c = sk[(int) i];
		(u8)[sk_ptr + i] = c;
		i += 1;
	}
}
