require "poly.jazz"
require "high-low-order.jazz"
require "fft.jazz"

inline
fn fft_vec(stack u32[Li2_l * Li2_polydeg] vec)
	-> stack u32[Li2_l * Li2_polydeg]
{
	inline int i;
	reg ptr u32[Li2_polydeg] entry;

	for i = 0 to Li2_l {
		entry = vec[i * Li2_polydeg : Li2_polydeg];
		entry = fft(entry);
		vec[i * Li2_polydeg : Li2_polydeg] = entry;
	}

	return vec;
}

inline
fn ifft_to_mont_vec(stack u32[Li2_k * Li2_polydeg] vec)
	-> stack u32[Li2_k * Li2_polydeg]
{
	inline int i;
	reg ptr u32[Li2_polydeg] entry;

	for i = 0 to Li2_k {
		entry = vec[i * Li2_polydeg : Li2_polydeg];
		entry = ifft_to_mont(entry);
		vec[i * Li2_polydeg : Li2_polydeg] = entry;
	}

	return vec;
}

inline
fn power2round_vec(stack u32[Li2_k * Li2_polydeg] v)
	-> stack u32[Li2_k * Li2_polydeg], stack u32[Li2_k * Li2_polydeg]
{
	stack u32[Li2_k * Li2_polydeg] t1 t0;
	reg u64 i;
	reg u32 x y1 y2;

	i = 0;
	while(i < Li2_k * Li2_polydeg) {
		x = v[(int) i];
		y1, y2 = power2round(x);
		t1[(int) i] = y1;
		t0[(int) i] = y2;
		i += 1;
	}

	return t1, t0;
}

inline
fn sum_vecs(stack u32[Li2_k * Li2_polydeg] v1 v2)
	-> stack u32[Li2_k * Li2_polydeg]
{
	stack u32[Li2_k * Li2_polydeg] vsum;
	inline int i;
	reg ptr u32[Li2_polydeg] v1_term v2_term vsum_term;
	
	for i = 0 to Li2_k {
		v1_term = v1[Li2_polydeg * i : Li2_polydeg];
		v2_term = v2[Li2_polydeg * i : Li2_polydeg];
		vsum_term = vsum[Li2_polydeg * i : Li2_polydeg];
		vsum_term = poly_add(v1_term, v2_term, vsum_term);
		vsum[Li2_polydeg * i : Li2_polydeg] = vsum_term;
	}
	return vsum;
}

inline
fn dot_prod_vecs(stack u32[Li2_l * Li2_polydeg] v1 v2, reg ptr u32[Li2_polydeg] dotprod)
	-> reg ptr u32[Li2_polydeg]
{	
	stack u32[Li2_polydeg] term_prod;

	reg ptr u32[Li2_polydeg] v1_term v2_term;

	inline int i;
	
	dotprod = zero_poly(dotprod);
	for i = 0 to Li2_l {
		v1_term = v1[Li2_polydeg * i : Li2_polydeg];
		v2_term = v2[Li2_polydeg * i : Li2_polydeg];
		term_prod = poly_mult(v1_term, v2_term, term_prod);
		dotprod = poly_accumulate(term_prod, dotprod);
	}

	return dotprod;
}

inline
fn mult_mat_vec(reg ptr u32[Li2_k * Li2_l * Li2_polydeg] mat,
	reg ptr u32[Li2_l * Li2_polydeg] vec)
	-> stack u32[Li2_k * Li2_polydeg]
{
	stack u32[Li2_k * Li2_polydeg] out;
	reg ptr u32[Li2_polydeg] prod;
	inline int i;

	for i = 0 to Li2_k {
		prod = out[Li2_polydeg * i : Li2_polydeg];
		prod = dot_prod_vecs(
			mat[Li2_l * Li2_polydeg * i : Li2_l * Li2_polydeg], 
			vec, prod);
		out[Li2_polydeg * i : Li2_polydeg] = prod;
	}

	return out;
}
