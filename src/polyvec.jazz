require "poly.jazz"
require "high-low-order.jazz"
require "fft.jazz"
require "montgomery_of_noise.jazz"

inline
fn fft_vec(stack u32[Li2_l * Li2_polydeg] vec)
	-> stack u32[Li2_l * Li2_polydeg]
{
	inline int i;
	reg ptr u32[Li2_polydeg] entry;

	for i = 0 to Li2_l {
		entry = vec[i * Li2_polydeg : Li2_polydeg];
		entry = fft(entry);
		vec[i * Li2_polydeg : Li2_polydeg] = entry;
	}

	return vec;
}

inline
fn ifft_vec(stack u32[Li2_k * Li2_polydeg] vec)
	-> stack u32[Li2_k * Li2_polydeg]
{
	inline int i;
	reg ptr u32[Li2_polydeg] entry;

	for i = 0 to Li2_k {
		entry = vec[i * Li2_polydeg : Li2_polydeg];
		entry = ifft(entry);
		vec[i * Li2_polydeg : Li2_polydeg] = entry;
	}

	return vec;
}

inline
fn power2round_vec(stack u32[Li2_k * Li2_polydeg] v)
	-> stack u32[Li2_k * Li2_polydeg], stack u32[Li2_k * Li2_polydeg]
{
	stack u32[Li2_k * Li2_polydeg] t1 t0;
	reg u64 i;
	reg u32 x y1 y2;

	i = 0;
	while(i < Li2_k * Li2_polydeg) {
		x = v[(int) i];
		y1, y2 = power2round(x);
		t1[(int) i] = y1;
		t0[(int) i] = y2;
		i += 1;
	}

	return t1, t0;
}

inline
fn sum_vecs(stack u32[Li2_k * Li2_polydeg] v1 v2)
	-> stack u32[Li2_k * Li2_polydeg]
{
	stack u32[Li2_k * Li2_polydeg] vsum;
	inline int i;
	reg ptr u32[Li2_polydeg] v1_term v2_term vsum_term;
	
	for i = 0 to Li2_k {
		v1_term = v1[Li2_polydeg * i : Li2_polydeg];
		v2_term = v2[Li2_polydeg * i : Li2_polydeg];
		vsum_term = vsum[Li2_polydeg * i : Li2_polydeg];
		vsum_term = poly_add(v1_term, v2_term, vsum_term);
		vsum[Li2_polydeg * i : Li2_polydeg] = vsum_term;
	}
	return vsum;
}

inline
fn dot_prod_vecs(stack u32[Li2_l * Li2_polydeg] v1 v2, reg ptr u32[Li2_polydeg] dotprod)
	-> reg ptr u32[Li2_polydeg]
{	
	stack u32[Li2_polydeg] term_prod;

	reg ptr u32[Li2_polydeg] v1_term v2_term;

	inline int i;
	
	dotprod = zero_poly(dotprod);
	for i = 0 to Li2_l {
		v1_term = v1[Li2_polydeg * i : Li2_polydeg];
		v2_term = v2[Li2_polydeg * i : Li2_polydeg];
		term_prod = poly_mult(v1_term, v2_term, term_prod);
		dotprod = poly_accumulate(term_prod, dotprod);
	}

	return dotprod;
}

inline
fn mult_mat_vec(reg ptr u32[Li2_k * Li2_l * Li2_polydeg] mat,
	reg ptr u32[Li2_l * Li2_polydeg] vec)
	-> stack u32[Li2_k * Li2_polydeg]
{
	stack u32[Li2_k * Li2_polydeg] out;
	reg ptr u32[Li2_polydeg] prod;
	inline int i;

	for i = 0 to Li2_k {
		prod = out[Li2_polydeg * i : Li2_polydeg];
		prod = dot_prod_vecs(
			mat[Li2_l * Li2_polydeg * i : Li2_l * Li2_polydeg], 
			vec, prod);
		out[Li2_polydeg * i : Li2_polydeg] = prod;
	}

	return out;
}

inline
fn make_montgomery_of_s1(reg ptr u32[Li2_l * Li2_polydeg] s1)
	-> stack u32[Li2_l * Li2_polydeg]
{
	stack u32[Li2_l * Li2_polydeg] mont_s1;
	reg ptr u32[9] montgomery_table;
	reg u64 i;
	reg u32 val;
	reg u32 eta_minus_x;
	reg u64 table_entry;

	montgomery_table = montgomery_from_eta_minus_x;
	i = 0;
	while(i < Li2_l * Li2_polydeg) {
		eta_minus_x = s1[(int) i];
		table_entry = (64u) eta_minus_x;
		val = montgomery_table[(int) table_entry];
		mont_s1[(int) i] = val;
		i += 1;
	}
	return mont_s1;
}

inline
fn make_montgomery_of_s2(reg ptr u32[Li2_k * Li2_polydeg] s2)
	-> stack u32[Li2_k * Li2_polydeg]
{
	stack u32[Li2_k * Li2_polydeg] mont_s2;
	reg ptr u32[9] montgomery_table;
	reg u64 i;
	reg u32 val;
	reg u32 eta_minus_x;
	reg u64 table_entry;

	montgomery_table = montgomery_from_eta_minus_x;
	i = 0;
	while(i < Li2_k * Li2_polydeg) {
		eta_minus_x = s2[(int) i];
		table_entry = (64u) eta_minus_x;
		val = montgomery_table[(int) table_entry];
		mont_s2[(int) i] = val;
		i += 1;
	}
	return mont_s2;
}

inline
fn redc_t(reg ptr u32[Li2_k * Li2_polydeg] t)
	-> reg ptr u32[Li2_k * Li2_polydeg]
{
	reg u64 i;
	reg u32 element;
	reg u64 redc_in;
	stack u32 redc_out;

	i = 0;
	while(i < Li2_k * Li2_polydeg) {
		element = t[(int) i];
		redc_in = (64u) element;
		redc_out = montgomery_REDC(redc_in);
		element = redc_out;
		t[(int) i] = element;
		i += 1;
	}

	return t;
}
