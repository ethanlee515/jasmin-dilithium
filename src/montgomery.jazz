require "params.jazz"

//Maybe combine into params.jazz?
param int twoTo32 = 4294967296;
param int twoTo32Minus1 = 4294967295;
param int dilithium_modulo = 8380417;
param int dilithium_modulo_left_shift_41 = 18428731874223325184;
param int dilithium_modulo_inv = 58728449;
param int dilithium_modulo_inv_neg = 4236238847;
param int dilithium_primitive_root = 1753;
param int m_1 = 4193792;
param int m_root = 2091667;

inline
fn montgomery_REDC(reg u64 x) -> stack u32
{
	stack u32 result;
	reg u64 m;

	reg u64 m_mod_Q;

	//m = ((x & twoTo32Minus1) * dilithium_modulo_inv_neg) & twoTo32Minus1;
	m = (64u) x;
	m &= twoTo32Minus1;
	m *= dilithium_modulo_inv_neg;
	m &= twoTo32Minus1;

	//t = (x + m * dilithium_N) >> 32
	m *= dilithium_modulo;
	m += (64u) x;
	m = m >> 32;

	m_mod_Q = m;
	m_mod_Q -= dilithium_modulo;

	m = m_mod_Q if (m >= dilithium_modulo);

	result = (32u) m;
	return result;
}

inline
fn montgomery_add(stack u32 sx sy) -> stack u32
{
	reg u32 x y;
	reg u32 result;
	stack u32 sr;

	reg u32 result_mod_q;

	x = sx;
	y = sy;
	result = x + y;

	result_mod_q = result;
	result_mod_q -= dilithium_modulo;

	result = result_mod_q if(result >=s dilithium_modulo);

	result_mod_q = result;
	result_mod_q += dilithium_modulo;

	result = result_mod_q if(result < 0);

	sr = result;
	return sr;
}

inline
fn montgomery_negate(stack u32 x) -> stack u32
{
	reg u32 rx;
	reg u32 temp;
	stack u32 result;

	rx = x;
	temp = Li2_q;
	temp -= rx;
	result = temp;
	return result;
}

inline
fn montgomery_subtract(stack u32 x y) -> stack u32
{
	stack u32 minus_y;
	stack u32 result;

	minus_y = montgomery_negate(y);
	result = montgomery_add(x, minus_y);
	
	return result;
}

inline
fn montgomery_mult(stack u32 x y) -> stack u32
{
	reg u64 xy;
	reg u64 temp;
	stack u32 result;

	xy = (64u) x;
	temp = (64u) y;
	xy *= temp;
	result = montgomery_REDC(xy);
	return result;
}

// Add Q if input coefficient is negative.
inline
fn caddq(reg u32 a) -> reg u32 {

	reg u32 a_add_q;

	a_add_q = a;
	a_add_q += Li2_q;

	a = a_add_q if(a <s 0);

	return a;
}

inline
fn checknorm(reg u32 val, inline int threshold)
	-> stack u8
{
	stack u8 result;
	result = 0;
	if(val >= threshold) {
		if(val <= Li2_q - threshold) {
			result = 1;
		}
	}
	return result;
}
