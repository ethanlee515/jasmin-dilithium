require "params.jazz"

//Maybe combine into params.jazz?
param int twoTo32 = 4294967296;
param int twoTo32Minus1 = 4294967295;
param int dilithium_modulo = 8380417;
param int dilithium_modulo_left_shift_41 = 18428731874223325184;
param int dilithium_modulo_inv = 58728449;
param int dilithium_modulo_inv_neg = 4236238847;
param int dilithium_primitive_root = 1753;
param int m_1 = 4193792;
param int m_root = 2091667;

inline
fn montgomery_REDC(reg u64 x) -> stack u32
{
	stack u32 result;
	reg u64 m;

	//m = ((x & twoTo32Minus1) * dilithium_modulo_inv_neg) & twoTo32Minus1;
	m = (64u) x;
	m &= twoTo32Minus1;
	m *= dilithium_modulo_inv_neg;
	m &= twoTo32Minus1;

	//t = (x + m * dilithium_N) >> 32
	m *= dilithium_modulo;
	m += (64u) x;
	m = m >> 32;

	if(m >= dilithium_modulo) {
		m -= dilithium_modulo;
	}

	result = (32u) m;
	return result;
}

inline
fn montgomery_add(stack u32 sx sy) -> stack u32
{
	reg u32 x y;
	reg u32 result;
	stack u32 sr;

	x = sx;
	y = sy;
	result = x + y;

	if(result >=s dilithium_modulo) {
		result -= dilithium_modulo;
	}

	if(result < 0) {
		result += dilithium_modulo;
	}

	sr = result;
	return sr;
}

inline
fn montgomery_negate(stack u32 x) -> stack u32
{
	reg u32 rx;
	reg u32 temp;
	stack u32 result;

	rx = x;
	temp = Li2_q;
	temp -= rx;
	result = temp;
	return result;
}

inline
fn montgomery_subtract(stack u32 x y) -> stack u32
{
	stack u32 minus_y;
	stack u32 result;

	minus_y = montgomery_negate(y);
	result = montgomery_add(x, minus_y);
	
	return result;
}

inline
fn montgomery_mult(stack u32 x y) -> stack u32
{
	reg u64 xy;
	reg u64 temp;
	stack u32 result;

	xy = (64u) x;
	temp = (64u) y;
	xy *= temp;
	result = montgomery_REDC(xy);
	return result;
}

// Add Q if input coefficient is negative.
inline
fn caddq(reg u32 a) -> reg u32 {
	// TODO make constant time ver.
	// See reference impl.
	if(a <s 0) {
		a += Li2_q;
	}
	return a;
}
