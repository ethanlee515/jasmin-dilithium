require "params.jazz"

//packing related parameters
param int Li2_pack_s1len = Li2_l * Li2_polydeg / 2;
param int Li2_pack_s2len = Li2_k * Li2_polydeg / 2;
param int Li2_pack_s2loc = 96 + Li2_pack_s1len;

// length of only one poly
// naming taken from C ref
param int Li2_pack_t1len = 10 * Li2_polydeg / 8;
// actual length is K times the above...

inline
fn polyt1_pack(reg ptr u32[Li2_polydeg] t1, reg ptr u8[Li2_pack_t1len] buf)
	-> reg ptr u8[Li2_pack_t1len]
{
	reg u64 i;
	reg u64 addr;
	reg u32 x x1;
	reg u8 c;
	
	i = 0;
	while(i < Li2_polydeg / 4) {
		// I already know I'm gonna typo this somewhere...
		// There's an argument to just use for-loop here...
		// Having i be inline int will greatly simplify the code
		// But compile time will probably be no good?

		//buf[5*i+0] = t1[4*i+0] >> 0;

		addr = 4;
		addr *= i;
		x = t1[(int) addr];
		c = (8u) x;

		addr = 5;
		addr *= i;
		buf[(int) addr] = c;

		//buf[5*i+1] = (t1[4*i+0] >> 8) | (t1[4*i+1] << 2);

		addr = 4;
		addr *= i;
		x = t1[(int) addr];
		x >>= 8;

		addr = 4;
		addr *= i;
		addr += 1;
		x1 = t1[(int) addr];
		x1 <<= 2;
		x |= x1;

		addr = 5;
		addr *= i;
		addr += 1;
		c = (8u) x;
		buf[(int) addr] = c;
		
		//buf[5*i+2] = (t1[4*i+1] >> 6) | (t1[4*i+2] << 4);

		addr = 4;
		addr *= i;
		addr += 1;
		x = t1[(int) addr];
		x >>= 6;

		addr = 4;
		addr *= i;
		addr += 2;
		x1 = t1[(int) addr];
		x1 <<= 4;
		x |= x1;

		addr = 5;
		addr *= i;
		addr += 2;
		c = (8u) x;
		buf[(int) addr] = c;

		//buf[5*i+3] = (t1[4*i+2] >> 4) | (t1[4*i+3] << 6);

		addr = 4;
		addr *= i;
		addr += 2;
		x = t1[(int) addr];
		x >>= 4;

		addr = 4;
		addr *= i;
		addr += 3;
		x1 = t1[(int) addr];
		x1 <<= 6;
		x |= x1;

		addr = 5;
		addr *= i;
		addr += 3;
		c = (8u) x;
		buf[(int) addr] = c;

		//buf[5*i+4] = (t1[4*i+3] >> 2);

		addr = 4;
		addr *= i;
		addr += 3;
		x = t1[(int) addr];
		x >>= 2;

		addr = 5;
		addr *= i;
		addr += 4;
		c = (8u) x;
		buf[(int) addr] = c;

		i += 1;
	}

	return buf;
}

inline
fn rho_pack(reg ptr u8[32] in out)
	-> reg ptr u8[32]
{
	inline int i;
	reg u8 c;
	for i = 0 to 32 {
		c = in[i];
		out[i] = c;
	}
	return out;
}

fn pack_s1(reg ptr u32[Li2_l * Li2_polydeg] s1, reg ptr u8[Li2_pack_s1len] dest)
	-> reg ptr u8[Li2_pack_s1len]
{
	reg u8 value;

	reg u32 lower higher;
	reg u32 temp;

	reg u64 i;

	reg u64 addr;

	i = 0;
	while(i < Li2_l * Li2_polydeg) {
		addr = i;
		addr >>= 1;

		temp = s1[(int) i];
		i += 1;
		//higher = eta_minus_x(temp);
		higher = temp;

		temp = s1[(int) i];
		i += 1;
		//lower = eta_minus_x(temp);
		lower = temp;
		
		/* Why is this not correct?
		higher <<= 4;
		higher += lower;
		value = (8u) higher;
		*/

		lower <<= 4;
		lower += higher;
		value = (8u) lower;
		
		dest[(int) addr] = value;
	}
	return dest;
}

fn pack_s2(reg ptr u32[Li2_k * Li2_polydeg] s1, reg ptr u8[Li2_pack_s2len] dest)
	-> reg ptr u8[Li2_pack_s2len]
{
	reg u8 value;

	reg u32 lower higher;
	reg u32 temp;

	reg u64 i;

	reg u64 addr;

	i = 0;
	while(i < Li2_k * Li2_polydeg) {
		addr = i;
		addr >>= 1;

		temp = s1[(int) i];
		i += 1;
		//higher = eta_minus_x(temp);
		higher = temp;

		temp = s1[(int) i];
		i += 1;
		//lower = eta_minus_x(temp);
		lower = temp;
		
		lower <<= 4;
		lower += higher;
		value = (8u) lower;
		
		dest[(int) addr] = value;
	}
	return dest;
}
