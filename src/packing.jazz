require "params.jazz"

inline
fn polyt1_pack(reg ptr u32[Li2_k * Li2_polydeg] t1, reg ptr u8[10 * Li2_polydeg * Li2_k / 8] buf)
	-> reg ptr u8[10 * Li2_polydeg * Li2_k / 8]
{
	reg u64 i;
	reg u64 addr;
	reg u32 x;
	reg u8 c;
	
	i = 0;
	while(i < Li2_polydeg / 4) {
		//TODO
		/*
		//buf[5*i+0] = t1[4*i+0] >> 0;
		x = t1[(int) (4 * i)];
		c = (8u) x;
		buf[(int) (5 * i)] = c;

		//buf[5*i+1] = (t1[4*i+0] >> 8) | (t1[4*i+1] << 2);
		x = t1[(int) (4 * i)];
		x >>= 8;
		c = (8u) x;
		x = t1[(int) (4 * i + 1)];
		x <<= 2;
		c |= x;
		buf[(int) (5 * i + 1)] = c;
		
		//buf[5*i+2] = (t1[4*i+1] >> 6) | (t1[4*i+2] << 4);
		x = t1[4 * i + 1];
		x >>= 6;
		c = (8u) x;
		x = t1[4 * i + 2];
		x <<= 4;
		c |= (8u) x;
		buf[5 * i + 2] = c;

		//buf[5*i+3] = (t1[4*i+2] >> 4) | (t1[4*i+3] << 6);
		x = t1[4 * i + 2];
		x >>= 4;
		c = (8u) x;
		x = t1[4 * i + 3];
		x <<= 6;
		c |= (8u) x;
		buf[5 * i + 3] = c;

		//buf[5*i+4] = (t1[4*i+3] >> 2);
		x = t1[4 * i + 3];
		x >>= 2;
		c = (8u) x;
		buf[5 * i + 4] = c;
		*/
		i += 1;
	}

	return buf;
}

inline
fn rho_pack(reg ptr u8[32] in out)
	-> reg ptr u8[32]
{
	inline int i;
	reg u8 c;
	for i = 0 to 32 {
		c = in[i];
		out[i] = c;
	}
	return out;
}

fn pack_s1(reg ptr u32[Li2_l * Li2_polydeg] s1, reg ptr u8[Li2_l * Li2_polydeg / 2] dest)
	-> reg ptr u8[Li2_l * Li2_polydeg / 2]
{
	reg u8 value;

	reg u32 lower higher;
	reg u32 temp;

	reg u64 i;

	reg u64 addr;

	i = 0;
	while(i < Li2_l * Li2_polydeg) {
		addr = i;
		addr >>= 1;

		temp = s1[(int) i];
		i += 1;
		higher = eta_minus_x(temp);

		temp = s1[(int) i];
		i += 1;
		lower = eta_minus_x(temp);
		
		/* Why is this not correct?
		higher <<= 4;
		higher += lower;
		value = (8u) higher;
		*/

		lower <<= 4;
		lower += higher;
		value = (8u) lower;
		
		dest[(int) addr] = value;
	}
	return dest;
}
