require "params.jazz"
require "montgomery.jazz"
require "packing.jazz"
require "fips202.jazz"
require "high-low-order.jazz"

inline
fn poly_add(reg ptr u32[Li2_polydeg] f g sum)
	-> reg ptr u32[Li2_polydeg]
{
	stack u32 x1 x2 y;
	reg u32 temp;

	reg u64 i;
	i = 0;
	while(i < Li2_polydeg) {
		temp = f[(int) i];
		x1 = temp;
		temp = g[(int) i];
		x2 = temp;
		y = montgomery_add(x1, x2);
		temp = y;
		sum[(int) i] = temp;
		i += 1;
	}
	return sum;
}

/* UNTESTED */
inline
fn poly_subtract(reg ptr u32[Li2_polydeg] f g difference)
	-> reg ptr u32[Li2_polydeg]
{
	stack u32 x1 x2 y;
	reg u32 temp;

	reg u64 i;
	i = 0;
	while(i < Li2_polydeg) {
		temp = f[(int) i];
		x1 = temp;
		temp = g[(int) i];
		x2 = temp;
		y = montgomery_subtract(x1, x2);
		temp = y;
		difference[(int) i] = temp;
		i += 1;
	}
	return difference;
}

inline
fn poly_accumulate(reg ptr u32[Li2_polydeg] f sum)
	-> reg ptr u32[Li2_polydeg]
{
	// Might need fix
	// Probably too much movement between reg and stack
	reg u32 temp;
	stack u32 x1 x2 y;

	reg u64 i;
	i = 0;
	while(i < Li2_polydeg) {
		temp = f[(int) i];
		x1 = temp;

		temp = sum[(int) i];
		x2 = temp;

		y = montgomery_add(x1, x2);
		temp = y;
		sum[(int) i] = temp;
		i += 1;
	}
	return sum;
}

// Tested in test_fft.cpp
inline
fn poly_mult(reg ptr u32[Li2_polydeg] fft_f fft_g fft_prod)
	-> reg ptr u32[Li2_polydeg]
{
	reg u64 i;
	reg u32 temp;
	stack u32 x1 x2 y;

	i = 0;
	while(i < Li2_polydeg) {
		// Probably too much movement between reg and stack
		// Might need fix

		temp = fft_f[(int) i];
		x1 = temp;
		temp = fft_g[(int) i];
		x2 = temp;
		y = montgomery_mult(x1, x2);
		temp = y;
		fft_prod[(int) i] = temp;
		i += 1;
	}
	return fft_prod;
}

inline
fn zero_poly(reg ptr u32[Li2_polydeg] f)
	-> reg ptr u32[Li2_polydeg]
{
	reg u64 i;
	i = 0;
	while(i < Li2_polydeg) {
		// Montgomery of 0 is 0
		f[(int) i] = 0;
		i += 1;
	}
	return f;
}

inline
fn expandMaskComponent(reg ptr u32[Li2_polydeg] f, reg ptr u8[64] rho_prime, stack u16 kappa)
	-> reg ptr u32[Li2_polydeg]
{
	reg u64 i;
	reg u8 c;
	reg u16 v;
	stack u64[25] state;
	stack u8[(Li2_pack_zlen / SHAKE256_RATE) * SHAKE256_RATE + SHAKE256_RATE] y_packed;
	stack u64 y_loc;
	stack u64 output_squeeze_counter;
	reg u64 addr;

	//there's an argument to call shake256_absorb66
	//that however introduces an extra copy

	state = st0(state);
	i = 0;
	while(i < 64) {
		c = rho_prime[(int) i];
		state[u8 (int) i] = c;
		i += 1;
	}

	v = kappa;
	v &= 255;
	c = (8u) v;
	state[u8 64] = c;

	v = kappa;
	v >>= 8;
	c = (8u) v;
	state[u8 65] = c;
	state[u8 66] ^= 0x1f;
	state[u8 SHAKE256_RATE - 1] ^= 0x80;

	y_loc = 0;

	output_squeeze_counter = 0;
	while(output_squeeze_counter < (Li2_pack_zlen / SHAKE256_RATE + 1)) {
		state = __keccakf1600_ref(state);

		i = 0;
		while(i < SHAKE256_RATE) {
			addr = i;
			c = state[u8 (int) addr];
			addr = y_loc;
			y_packed[(int) addr] = c;
			y_loc += 1;
			i += 1;
		}

		output_squeeze_counter += 1;
	}

	f = polyz_unpack(f, y_packed[0 : Li2_pack_zlen]);

	return f;
}

inline
fn poly_caddq(reg ptr u32[Li2_polydeg] f)
	-> reg ptr u32[Li2_polydeg]
{
	reg u64 i;
	reg u32 val;
	i = 0;
	while(i < Li2_polydeg) {
		val = f[(int) i];
		val = caddq(val);
		f[(int) i] = val;
		i += 1;
	}
	return f;
}


inline
fn poly_make_hint(reg ptr u32[Li2_polydeg] f0 f1 hints)
	-> stack u32, reg ptr u32[Li2_polydeg]
{
	stack u32 weight;
	reg u64 i;
	reg u32 a0 a1;
	reg u32 h;

	i = 0;
	while(i < Li2_polydeg) {
		hints[(int) i] = 0;
		i += 1;
	}

	weight = 0;
	i = 0;
	while(i < Li2_polydeg) {
		a0 = f0[(int) i];
		a1 = f1[(int) i];
		h = make_hint(a0, a1);
		hints[(int) i] = h;
		weight += h;
		i += 1;
	}

	return weight, hints;
}

inline
fn poly_use_hint(reg ptr u32[Li2_polydeg] f b hints)
	-> reg ptr u32[Li2_polydeg]
{
	reg u64 i;
	reg u32 a h c;


	i = 0;
	while(i < Li2_polydeg){
		a = f[(int) i];
		h = hints[(int) i];
		c = use_hint(h, a);
		b[(int) i] = c;
		i += 1;
	}
	return b;
}		


inline
fn poly_checknorm(reg ptr u32[Li2_polydeg] f, inline int threshold)
	-> stack u8
{
	stack u8 r;
	reg u8 result;
	stack u8 result_s;
	reg u8 c;
	reg u64 i;
	reg u32 val;

	result = 0;

	i = 0;
	while(i < Li2_polydeg) {
		val = f[(int) i];
		r = checknorm(val, threshold);
		c = r;
		result |= c;
		i += 1;
	}

	result_s = result;
	return result_s;
}
