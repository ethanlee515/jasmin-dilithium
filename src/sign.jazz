require "params.jazz"
require "hashing.jazz"

inline
fn compute_mu(reg u64 ptr_m, reg u64 m_len, reg ptr u8[Li2_SK_LEN] sk)
	-> stack u8[64]
{
	stack u8[64] mu;
	mu = hash_tr_m(sk[64:32], m_len, ptr_m);
	return mu;
}

inline
fn sign(reg u64 ptr_m,
		reg u64 m_len,
		reg ptr u8[Li2_SK_LEN] sk)
		-> stack u8[Li2_SIGN_LEN]
{
	stack u8[Li2_SIGN_LEN] signature;
	reg ptr u8[32] k;
	stack u32[Li2_l * Li2_polydeg] s1;
	stack u32[Li2_k * Li2_polydeg] s2;

	stack u8[64] mu;

	stack u32[Li2_k * Li2_l * Li2_polydeg] fft_matA;
	stack u32[Li2_l * Li2_polydeg] s1;
	stack u32[Li2_k * Li2_polydeg] s2;
	stack u32[Li2_k * Li2_polydeg] t;

	// corresponds to kappa/l in spec
	stack u32 nonce;
	
	fft_matA = gen_matrix(sk[0:32]);
	mu = compute_mu(ptr_m, m_len, sk);

	nonce = 0;
	

	

	return signature;
}

export
fn sign_jazz(reg u64 ptr_signature, reg u64 ptr_m, reg u64 m_len, reg u64 ptr_sk) {
	stack u8[Li2_SK_LEN] sk;
	reg u8 c;
	reg u64 i;
	stack u8[Li2_SIGN_LEN] signature;
	
	i = 0;
	while(i < Li2_SK_LEN) {
		c = (u8)[ptr_sk + i];
		sk[(int) i] = c;
		i += 1;
	}

	signature = sign(ptr_m, m_len, sk);

	i = 0;
	while(i < Li2_SIGN_LEN) {
		c = signature[(int) i];
		(u8) [ptr_signature] = c;
		i += 1;
	}
}
