require "params.jazz"

fn power2round(reg u32 r)
	-> reg u32, reg u32
{
	reg u32 highbits, lowbits;

	//highbits = r >> Li2_d;
	highbits = r;
	highbits >>= Li2_d;

	lowbits = r & (Li2_expd - 1);

	if(lowbits > Li2_expd / 2) {
		lowbits = Li2_q + lowbits - Li2_expd;
		highbits += 1;
	}

	return highbits, lowbits;
}

// high bits = a0, low bits = a1
inline
fn decompose(reg u32 a) -> reg u32, reg u32 {
	reg u64 a0;
	reg u32 a0_32;
	reg u32 a1;
	reg u32 v;
	reg u64 v64;

	// a1  = (a + 127) >> 7;
	a1 = a;
	a1 += 127;
	a1 >>= 7;

	// a1  = (a1*1025 + (1 << 21)) >> 22;
	a1 *= 1025;
	a1 += (int) (1 << 21);
	a1 >>= 22;

	// a1 &= 15;
	a1 &= 15;

	// *a0  = a - a1*2*GAMMA2;
	v64 = (64u) a1;
	v64 *= 2 * Li2_gamma2;
	a0 = (64u) a;
	a0 -= v64;

	// *a0 -= (((Q-1)/2 - *a0) >> 31) & Q;
	v64 = (Li2_q - 1) / 2;
	v64 -= a0;
	v64 >>= 31;
	v64 &= Li2_q;
	a0 -= v64;

	a0_32 = (32u) a0;

	return a0_32, a1;
}

// TODO just check reference impl
// This doesn't seem very consistent with the spec
// was this even tested?
inline
fn make_hint(reg u32 a0, reg u32 a1) -> reg u32 {
	reg u32 result;
	reg u32 b1 b2;

	result = 0;


	b1 = 0;
	if(a0 > Li2_gamma2) {
		b1 = 1;
	}
	b2 = 0;
	if(a0 <= Li2_q / 2) {
		b2 = 1;
	}
	b2 &= b1;

	if(b2 == 1) {
		result = 1;
	}
	else {
		b1 = 0;
		if(a0 < Li2_q - Li2_gamma2) {
			b1 = 1;
		}
		b2 = 0;
		if(a0 > Li2_q / 2) {
			b2 = 1;
		}
		b2 &= b1;
		if(b2 == 1) {
			result = 1;
		}
		else {
			if(a0 == -Li2_gamma2) {
				if(a1 != 0) {
					result = 1;
				}
			}
		}
	}
	return result;
}



// use_hint for level-3 parameters
inline
fn use_hint(reg u32 hint, reg u32 a)
	-> reg u32
{
	reg u32 a0 a1;
	reg u32 result;
	a0, a1 = decompose(a);
	if (hint == 0){
		result = a1;
	}
	if (a0 > 0){
		a1 += 1;
		a1 &= 15;
		result = a1;
	}
	else {
		a1 -= 1;
		a1 &= 15;
		result = a1;
	}
	return result;
}
