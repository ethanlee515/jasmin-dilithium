require "params.jazz"

fn power2round(reg u32 r)
	-> reg u32, reg u32
{
	reg u32 highbits, lowbits;

	//highbits = r >> Li2_d;
	highbits = r;
	highbits >>= Li2_d;

	lowbits = r & (Li2_expd - 1);

	if(lowbits > Li2_expd / 2) {
		lowbits = Li2_q + lowbits - Li2_expd;
		highbits += 1;
	}

	return highbits, lowbits;
}

// high bits = a0, low bits = a1
inline
fn decompose(reg u32 a) -> reg u32, reg u32 {
	reg u32 a0;
	reg u32 a1;
	reg u32 v;

	// a1  = (a + 127) >> 7;
	a1 = a;
	a1 += 127;
	a1 >>= 7;

	// a1  = (a1*1025 + (1 << 21)) >> 22;
	a1 *= 1025;
	a1 += (int) (1 << 21);
	a1 >>= 22;

	// a1 &= 15;
	a1 &= 15;

	// *a0  = a - a1*2*GAMMA2;
	a0 = a1;
	a0 *= - 2 * Li2_gamma2;
	a0 += a;

	// *a0 -= (((Q-1)/2 - *a0) >> 31) & Q;
	v = ((Li2_q) - 1) / 2;
	v -= a0;
	v >>= 31;
	v &= Li2_q;
	a0 -= v;

	return a0, a1;
}

// TODO just check reference impl
// This doesn't seem very consistent with the spec
// was this even tested?
inline
fn make_hint(reg u32 a0, reg u32 a1) -> reg u32 {
	reg u32 result;

	result = 0;

	if(a0 > Li2_gamma2) {
		if(a0 <= Li2_q / 2) {
			result = 1;
		}
	}
	else {
		if(a0 > Li2_q / 2) {
			if(a0 < Li2_q - Li2_gamma2) {
				result = 1;
			}
		}
		else {
			if(a0 == Li2_q - Li2_gamma2) {
				if(a1 != 0) {
					result = 1;
				}
			}
		}
	}

	/*
	if (a0 >s Li2_gamma2) {
		result = 1;
	}
	else {
		if(a0 <s -Li2_gamma2) {
			result = 1;
		}
		else {
			if(a0 == -Li2_gamma2) {
				if(a1 != 0) {
					result = 1;
				}
			}
		}
	}
	*/
	return result;
}

// use_hint for level-3 parameters
inline
fn use_hint(reg u32 hint, reg u32 a)
	-> reg u32
{
	reg u32 a0;
	reg u32 a1;
	a0, a1 = decompose(a);
	if (hint == 0)
		return a1;
	if (a0 > 0)
		a1 += 1;
		a1 &= 15;
		return a1;
	else
		a1 -= 1;
		a1 &= 15;
		return  a1;
}
