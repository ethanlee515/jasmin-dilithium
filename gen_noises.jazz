#ifndef GEN_NOISES
#define GEN_NOISES

#include "fips202.jazz"
#include "params.jazz"

//reminder to self
//param int SHAKE256_RATE = 136;

inline
fn gen_noises_entry(stack u8[64] rho_prime, inline int i)
	-> stack u32[DILITHIUM_polydeg]
{
	// Poly
	stack u32[DILITHIUM_polydeg] result;
	stack u8 term;

	// For keccak
	stack u64[25] state;
	reg u64 offset;

	// temps
	inline int i;
	reg u8 c1 c2;
	reg u32 v;
	reg u64 addr;

	stack u8[66] seed;

	for i = 0 to 64 {
		c1 = rho_prime[i];
		seed[i] = c1;
	}
	
	seed[65] = i;
	seed[66] = 0;

	state = shake256_absorb66(seed);
	state = __keccakf1600_ref(state);
	offset = 0;

	term = 0;
	while(term < 256) {
		if(offset >= SHAKE256_RATE) {
			state = __keccakf1600_ref(state);
			offset = 0;
		}
		

		c1 = state[u8 (int) offset];
		c2 = c1;
		c1 >>= 2;
		c2 &= 15;

		if(c1 <= 9) {
			if(c1 <= 4) {
				v = 4;
			} else {
				v = DILITHIUM_q + 4;
			}
			v -= (32u) c1;
			result[(int) term] = v;
			term += 1;
		}

		if(c2 <= 9) {
			if(term < 256) {
				if(c1 <= 4) {
					v = 4;
				} else {
					v = DILITHIUM_q + 4;
				}
				v -= (32u) c1;
				result[(int) term] = v;
				term += 1;
			}
		}
	}

	return result;
}


inline
fn gen_noises(stack u8[64] rho_prime)
	-> stack u32[DILITHIUM_l * DILITHIUM_polydeg], stack u32[DILITHIUM_k * DILITHIUM_polydeg]
{
	stack u32[DILITHIUM_polydeg] entry;
	stack u32[DILITHIUM_l * DILITHIUM_polydeg] s1;
	stack u32[DILITHIUM_k * DILITHIUM_polydeg] s2;

	inline int i j;

	for i = 0 to DILITHIUM_l {
		entry = gen_noises_entry(rho_prime, i);

		//TODO subarray maybe...?
		for j = 0 to DILITHIUM_polydeg {
			s1[DILITHIUM_polydeg * i + j] = entry[j];
		}
	}

	for i = 0 to DILITHIUM_k {
		entry = gen_noises_entry(rho_prime, i + DILITHIUM_l);
		for j = 0 to DILITHIUM_polydeg {
			s2[DILITHIUM_polydeg * (i + DILITHIUM_l) + j] = entry[j];
		}
	}

	return s1, s2;
}

#endif
